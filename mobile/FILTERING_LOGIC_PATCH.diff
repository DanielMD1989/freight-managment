diff --git a/mobile/lib/core/services/truck_service.dart b/mobile/lib/core/services/truck_service.dart
--- a/mobile/lib/core/services/truck_service.dart (BEFORE)
+++ b/mobile/lib/core/services/truck_service.dart (AFTER)

=== CHANGE 1: New searchTruckPostings Method with Full Filter Support ===

+  /// Search truck postings with FULL posting data (WEB PARITY)
+  /// Returns TruckPosting objects with origin/destination, age, availability
+  /// Matches web SearchTrucksTab.tsx filter parameters
+  Future<ApiResponse<TruckPostingSearchResult>> searchTruckPostings({
+    int page = 1,
+    int limit = 20,
+    String? origin,        // origin city filter (availableCity)
+    String? destination,   // destination city filter (WEB PARITY)
+    String? truckType,
+    String? fullPartial,   // FULL, PARTIAL, BOTH (WEB PARITY)
+    double? minLength,     // minimum trailer length (WEB PARITY)
+    double? maxWeight,     // maximum weight capacity (WEB PARITY)
+    DateTime? availableFrom, // availability date filter (WEB PARITY)
+    int? ageHours,         // max posting age in hours (WEB PARITY)
+    String? sortBy,
+    String? sortOrder,
+  }) async {
+    try {
+      final params = <String, dynamic>{
+        'page': page.toString(),
+        'limit': limit.toString(),
+        'status': 'ACTIVE', // Only show active postings
+      };
+
+      // Origin filter (matches web's "origin" filter)
+      if (origin != null && origin.isNotEmpty) {
+        params['origin'] = origin;
+      }
+      // Destination filter (WEB PARITY - web uses "destination")
+      if (destination != null && destination.isNotEmpty) {
+        params['destination'] = destination;
+      }
+      if (truckType != null) params['truckType'] = truckType;
+      // Full/Partial filter (WEB PARITY)
+      if (fullPartial != null) params['fullPartial'] = fullPartial;
+      // Length filter (WEB PARITY)
+      if (minLength != null) params['minLength'] = minLength.toString();
+      // Weight filter (WEB PARITY)
+      if (maxWeight != null) params['maxWeight'] = maxWeight.toString();
+      // Availability date filter (WEB PARITY)
+      if (availableFrom != null) {
+        params['availableFrom'] = availableFrom.toIso8601String().split('T')[0];
+      }
+      // Age filter (WEB PARITY - filter by posting age)
+      if (ageHours != null) params['ageHours'] = ageHours.toString();
+      if (sortBy != null) params['sortBy'] = sortBy;
+      if (sortOrder != null) params['sortOrder'] = sortOrder;
+
+      final response = await _apiClient.dio.get(
+        '/api/truck-postings',
+        queryParameters: params,
+      );
+
+      if (response.statusCode == 200) {
+        // Parse full posting data (NOT just the truck)
+        final postingsData = response.data['truckPostings'] ??
+                            response.data['postings'] ??
+                            response.data['trucks'] ?? [];
+        final postings = (postingsData as List)
+            .map((json) => TruckPosting.fromJson(json))
+            .toList();
+        final pagination = response.data['pagination'] ?? {};
+
+        return ApiResponse.success(TruckPostingSearchResult(
+          postings: postings,
+          page: pagination['page'] ?? page,
+          limit: pagination['limit'] ?? limit,
+          total: pagination['total'] ?? postings.length,
+          pages: pagination['pages'] ?? 1,
+        ));
+      }
+
+      return ApiResponse.error(
+        response.data['error'] ?? 'Failed to search truck postings',
+        statusCode: response.statusCode,
+      );
+    } on DioException catch (e) {
+      return ApiResponse.error(e.friendlyMessage, statusCode: e.response?.statusCode);
+    } catch (e) {
+      return ApiResponse.error('An unexpected error occurred: $e');
+    }
+  }


=== CHANGE 2: New TruckPostingSearchResult Class ===

+/// Truck POSTING search result with FULL posting data (WEB PARITY)
+/// Includes origin/destination direction, age, availability, carrier info
+class TruckPostingSearchResult {
+  final List<TruckPosting> postings;
+  final int page;
+  final int limit;
+  final int total;
+  final int pages;
+
+  TruckPostingSearchResult({
+    required this.postings,
+    required this.page,
+    required this.limit,
+    required this.total,
+    required this.pages,
+  });
+
+  bool get hasMore => page < pages;
+}


=== CHANGE 3: Extended TruckPosting Model ===

diff --git a/mobile/lib/core/models/truck.dart b/mobile/lib/core/models/truck.dart

 class TruckPosting {
   final String id;
   final String truckId;
   final Truck? truck;
   final String status;
   final String? originCityId;
   final String? destinationCityId;
   final String? originCityName;
   final String? destinationCityName;
+  final double? originLat;       // WEB PARITY: for direction
+  final double? originLng;
+  final double? destinationLat;
+  final double? destinationLng;
   final DateTime availableFrom;
   final DateTime? availableTo;
   final String? fullPartial;
   final double? availableLength;
   final double? availableWeight;
   final String? notes;
   final String? contactName;
   final String? contactPhone;
   final String? ownerName;
   final String carrierId;
+  final String? carrierName;     // WEB PARITY: carrier display
+  final bool? carrierIsVerified;
   final DateTime createdAt;
+  final DateTime? postedAt;      // WEB PARITY: for age calculation
   ...

   factory TruckPosting.fromJson(Map<String, dynamic> json) {
+    // Parse origin city data (matches web API response structure)
+    final originCity = json['originCity'];
+    final destinationCity = json['destinationCity'];
+    final carrier = json['carrier'];
+
     return TruckPosting(
       id: json['id'] ?? '',
       ...
-      originCityName: json['originCity']?['name'] ?? json['originCityName'],
-      destinationCityName: json['destinationCity']?['name'] ?? json['destinationCityName'],
+      // Parse city names from nested objects (web API format)
+      originCityName: originCity is Map ? originCity['name'] : json['originCityName'],
+      destinationCityName: destinationCity is Map ? destinationCity['name'] : json['destinationCityName'],
+      // Parse coordinates for direction calculation
+      originLat: originCity is Map ? _parseDouble(originCity['latitude']) : null,
+      originLng: originCity is Map ? _parseDouble(originCity['longitude']) : null,
+      destinationLat: destinationCity is Map ? _parseDouble(destinationCity['latitude']) : null,
+      destinationLng: destinationCity is Map ? _parseDouble(destinationCity['longitude']) : null,
       ...
+      // Parse carrier info (web API includes carrier object)
+      carrierName: carrier is Map ? carrier['name'] : json['carrierName'],
+      carrierIsVerified: carrier is Map ? carrier['isVerified'] : json['carrierIsVerified'],
+      postedAt: json['postedAt'] != null ? DateTime.parse(json['postedAt']) : null,
     );
   }


=== CHANGE 4: Added Helper Methods for Display ===

+  /// Route display: "Origin → Destination" or "Origin → Any"
+  String get routeDisplay {
+    final origin = originCityName ?? 'Unknown';
+    final dest = destinationCityName ?? 'Any';
+    return '$origin → $dest';
+  }

+  /// Age display: "2h", "1d", "3d" etc. (matches web behavior)
+  String get ageDisplay {
+    final posted = postedAt ?? createdAt;
+    final diff = DateTime.now().difference(posted);
+
+    if (diff.inMinutes < 60) {
+      return '${diff.inMinutes}m';
+    } else if (diff.inHours < 24) {
+      return '${diff.inHours}h';
+    } else {
+      return '${diff.inDays}d';
+    }
+  }

+  /// Full/Partial display
+  String get fullPartialDisplay {
+    switch (fullPartial?.toUpperCase()) {
+      case 'FULL':
+        return 'F';
+      case 'PARTIAL':
+        return 'P';
+      case 'BOTH':
+        return 'F/P';
+      default:
+        return 'F';
+    }
+  }

+  /// Availability date display
+  String get availabilityDisplay {
+    final now = DateTime.now();
+    final diff = availableFrom.difference(now);
+
+    if (diff.isNegative || diff.inHours < 24) {
+      return 'Now';
+    } else if (diff.inDays < 7) {
+      return '${diff.inDays}d';
+    } else {
+      return '${availableFrom.month}/${availableFrom.day}';
+    }
+  }

+  /// Company name (carrier or owner)
+  String get companyDisplay {
+    return carrierName ?? ownerName ?? 'Unknown';
+  }


=== Summary of Filtering Logic Changes ===

1. New searchTruckPostings() method supports all web filters:
   - origin (city)
   - destination (city)
   - truckType
   - fullPartial (FULL/PARTIAL/BOTH)
   - minLength
   - maxWeight
   - availableFrom
   - ageHours

2. TruckPosting model extended with:
   - originLat/Lng, destinationLat/Lng for direction
   - carrierName, carrierIsVerified for carrier display
   - postedAt for age calculation

3. Helper methods added for UI display:
   - routeDisplay: "Addis Ababa → Dire Dawa"
   - ageDisplay: "2h", "1d"
   - fullPartialDisplay: "F", "P", "F/P"
   - availabilityDisplay: "Now", "2d"
   - companyDisplay: carrier name
